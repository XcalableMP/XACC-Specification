\chapter{{\XMP} Extension}\label{chap:xmp-ex}
This chapter defines a behavior of mixing {\XMP} and {\OACC}.
Note that the existing {\OACC} is not extended in the {\XMP} extension.
The {\XMP} extension can represent 
(1) parallelization with keeping sequential code image using a combination of {\XMP} and {\OACC},
and
(2) communication among accelerator memories and between accelerator memory and host memory on different {\tt nodes}
using {\XACC} directives or {\tt coarray} features.

\section{Combination of {\XMP} and {\OACC}}
\subsection{{\OACC} Directives on Data}
\subsubsection*{Description}
When {\tt distributed arrays} appear in {\OACC} constructs,
global indices in {\tt distributed arrays} are used.
%Thus,
%an {\XACC} compiler automatically translates the global indices in the {\OACC} constructs to the appropriate local indices.
The {\tt distributed arrays} may appear in the {\OACC} {\bf update}, {\bf enter data}, {\bf exit data}, 
{\bf host\_data}, {\bf cache}, and {\bf declare} directives,
and the {\bf data} clause accompanied by some of 
{\bf deviceptr}, {\bf present}, {\bf copy}, {\bf copyin}, 
{\bf copyout}, {\bf create}, and {\bf delete} clauses.
Data transfer of {\tt distributed array} by {\OACC} is performed on only {\tt nodes} which have elements specified by the global indices.

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
integer :: a(N), b(N)
!$xmp template t(N)
!$xmp nodes p(*)
!$xmp distribute t(block) onto p
!$xmp align a(i) with t(i)
!$xmp align b(i) with t(i)
...
!$acc enter data copyin(a(1:k))
!$acc data copy(b)
...
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
int a[N], b[N];
#pragma xmp template t[N]
#pragma xmp nodes p[*]
#pragma xmp distribute t[block] onto p
#pragma xmp align a[i] with t[i]
#pragma xmp align b[i] with t[i]
...
#pragma acc enter data copyin(a[0:k])
#pragma acc data copy(b)
{ ...
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XMP} extension with {\OACC} {\bf enter\_data} directive}\label{code:ex-oacc-data}
\end{myfigure}

In lines 2-6,
{\XMP} directives declare the {\tt distributed arrays} {\it a} and {\it b}.
In line 8,
the {\OACC} {\bf enter data} directive transfers the certain range of the {\tt distributed array} {\it a} from host memory to accelerator memory.
Note that the range is represented by global indices.
In line 9,
the {\OACC} {\bf data} directive transfers the whole {\tt distributed array} {\it b} from host memory to accelerator memory.

\subsection{{\OACC} Loop Construct}
\subsubsection*{Description}
In order to parallelize a loop statement on multiple accelerators on multiple {\tt nodes},
{\XMP} {\bf loop} directive and {\OACC} {\bf loop} directive are used.
While
{\XMP} {\bf loop} directive parallelizes a loop statement on each {\tt node},
{\OACC} {\bf loop} directive parallelizes the loop statement parallelized by {\XMP} {\bf loop} directive on each accelerator.
The order of {\XMP} {\bf loop} directive and {\OACC} {\bf loop} directive does not matter.

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
integer :: a(N), b(N), sum = 0
!$xmp template t(N)
!$xmp nodes p(*)
!$xmp distribute t(block) onto p
!$xmp align a(i) with t(i)
!$xmp align b(i) with t(i)
...
!$acc parallel copy(a, b, sum)

!$xmp loop on t(i)
!$acc loop
do i=0, N
  b(i) = a(i)
end do
!$xmp loop on t(i) reduction(+:sum)
!$acc loop reduction(+:sum)
do i=0, N
  sum = sum + b(i)
end do
!$acc end parallel
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
int a[N], b[N], sum = 0;
#pragma xmp template t[N]
#pragma xmp nodes p[*]
#pragma xmp distribute t[block] onto p
#pragma xmp align a[i] with t[i]
#pragma xmp align b[i] with t[i]
...
#pragma acc parallel copy(a, b, sum)
{
#pragma xmp loop on t[i]
#pragma acc loop
  for(int i=0;i<N;i++){
    b[i] = a[i];
  }
#pragma xmp loop on t[i] reduction(+:sum)
#pragma acc loop reduction(+:sum)
  for(int i=0;i<N;i++){
    sum += b[i];
  }
}
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XMP} extension with {\OACC} loop construct}\label{code:ex-oacc-loop}
\end{myfigure}

In lines 2-6,
{\XMP} directives declare {\tt distributed arrays} {\it a} and {\it b}.
In line 8,
{\OACC} {\bf parallel} directive starts {\tt parallel region} and transfers the {\tt distributed arrays} {\it a} and {\it b} and local variable {\it sum} from host memory to accelerator memory.
In line 10,
{\XMP} {\bf loop} directive parallelizes the next loop statement depending on the {\tt template} {\it t} on each {\tt node}.
In line 11,
{\OACC} {\bf loop} directive also parallelizes the next loop statement parallelized by {\XMP} on each accelerator.
In lines 15-16, 
{\bf reduction} clauses are added in both {\bf loop} directives.
At the end of the both {\bf loop} constructs, 
the reduction operations occur to calculate 
the total value of the local variable {\it sum} stored on each accelerator memory in each {\tt node}.

\section{Communication on Accelerated Clusters}
\subsection{{\XACC} Directives}
{\XACC} directives are extensions of {\XMP} {\bf reflect}, {\bf gmove}, 
{\bf barrier}, {\bf reduction}, {\bf bcast}, and {\bf wait\_async} directives in {\XMP} global-view memory model.
When adding an {\bf acc} clause to the above {\XMP} directives,
data stored on accelerator memory are transferred.
Note that while XcalableACC {\bf gmove} directive described in Section \ref{sec:reflect} 
and {\tt coarray} features described in Section \ref{sec:coarray} can occur communication both among accelerator memories and between accelerator memory and host memory on different {\tt nodes},
other directives can occur communication only among accelerator memories.

This section describes only the extended parts of {\XACC} directives from {\XMP} directives. 
For other information, refer to the {\XMP} specification\cite{xmp}.

\subsubsection{reflect Construct}\label{sec:reflect}
\subsubsection*{Synopsis}
The {\bf reflect} construct assigns the value of a
reflection source to the corresponding shadow object.

\subsubsection*{Syntax}
\begin{tabular}{ll}
 \verb![F]! & \verb|!$xmp| {\tt reflect} \verb|(| {\it array-name}
 {\openb}, {\it array-name}{\closeb}... \verb|)| {\bsquare} \\
 &\hspace{0.1cm} {\bsquare} {\openb}{\tt width (} {\it reflect-width}
     {\openb}, {\it reflect-width}{\closeb}... {\tt )}{\closeb}
     {\openb}{\tt orthogonal}{\closeb}
     {\openb}{\tt async (} {\it async-id} {\tt )}{\closeb} {\openb}{\tt acc}{\closeb}\\
\verb![C]! & \verb|#pragma xmp| {\tt reflect} \verb|(| {\it array-name}
     {\openb}, {\it array-name}{\closeb}... \verb|)| {\bsquare} \\
 &\hspace{0.1cm} {\bsquare} {\openb}{\tt width (} {\it reflect-width}
     {\openb}, {\it reflect-width}{\closeb}... {\tt )}{\closeb}
     {\openb}{\tt orthogonal}{\closeb}
     {\openb}{\tt async (} {\it async-id} {\tt )}{\closeb} {\openb}{\tt acc}{\closeb}\\
\end{tabular}

\vspace{1em}
where {\it reflect-width} must be one of:
\vspace{1em}

\begin{tabular}{ll}
 \hspace{0.5cm} & {\openb}{\tt /periodic/}{\closeb} {\it int-expr} \\
                & {\openb}{\tt /periodic/}{\closeb} {\it int-expr} : {\it int-expr}
\end{tabular}

\subsubsection*{Description}
When the {\bf acc} clause is specified,
the {\bf reflect} construct updates each of the shadow object of the
array specified by {\it array-name} on accelerator memory with the value of its corresponding
reflection source.

\subsubsection*{Restriction}
\begin{itemize}
 \item When the {\bf acc} clause is specified,
   the arrays specified by the sequence of {\it array-name}'s must be allocated on accelerator memory.
 \item This construct must not appear in {\OACC} {\tt parallel region}.
\end{itemize}

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
integer :: a(N)
!$xmp template t(N)
!$xmp nodes p(*)
!$xmp distribute t(block) onto p
!$xmp align a(i) with t(i)
!$xmp shadow a(1)
...
!$acc enter data copyin(a)
!$xmp reflect (a) acc
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
int a[N];
#pragma xmp template t[N]
#pragma xmp nodes p[*]
#pragma xmp distribute t[block] onto p
#pragma xmp align a[i] with t[i]
#pragma xmp shadow a[1]
...
#pragma acc enter data copyin(a)
#pragma xmp reflect (a) acc
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XACC} {\bf reflect} construct}\label{code:reflect}
\end{myfigure}

In lines 2-5,
{\XMP} directives declare {\tt distributed array} {\it a}.
In line 6, 
{\XMP} {\bf shadow} directive allocates shadow areas of the {\tt distributed array} {\it a}.
In line 8,
{\OACC} {\bf enter data} directive transfers the {\tt distributed array} {\it a} with the shadow areas from host memory to accelerator memory.
In line 9,
{\XACC} {\bf reflect} directive updates the shadow areas of the {\tt distributed array} {\it a} on accelerator memory between neighboring {\tt nodes}.

\subsubsection{gmove Construct}\label{sec:gmove}
\subsubsection*{Synopsis}
The {\tt \Directive{gmove}} construct allows an assignment statement,
which may cause communication, to be executed possibly in parallel by
the executing {\tt nodes}.

\subsubsection*{Syntax}
\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt gmove} {\openb}{\tt in} $\vert$ {\tt
 out}{\closeb} {\openb}{\tt async (} {\it async-id} {\tt )}{\closeb} {\openb}{\tt acc}{\openb}({\it variable}){\closeb}{\closeb}\\
\verb![C]! & \verb|#pragma xmp| {\tt gmove} {\openb}{\tt in} $\vert$ {\tt
 out}{\closeb} {\openb}{\tt async (} {\it async-id} {\tt )}{\closeb} {\openb}{\tt acc}{\openb}({\it variable}){\closeb}{\closeb}\\
\end{tabular}

\subsubsection*{Description}
\begin{itemize}
 \item When the {\bf acc} clause is specified and the variable is not specified by {\it variable} in the parenthesis,
variables of both sides in the assignment statement on accelerator memory are targeted.
 \item When the {\bf acc} clause is specified and the variable is specified by {\it variable} in the parenthesis,
the specified variable on accelerator memory is targeted, 
and the unspecified variable on host memory is targeted.
\end{itemize}

\subsubsection*{Restriction}
\begin{itemize}
 \item The variables targeted on accelerator memory must be allocated on accelerator memory.
 \item This construct must not appear in {\OACC} {\tt parallel region}.
\end{itemize}

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
integer :: a(N), b(N)
!$xmp template t(N)
!$xmp nodes p(*)
!$xmp distribute t(block) onto p
!$xmp align a(i) with t(i)
!$xmp align b(i) with t(i)
...
!$acc enter data copyin(a, b)
!$xmp gmove acc
  a(:) = b(:)

!$xmp gmove acc(b)
  a(:) = b(:)
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
int a[N], b[N];
#pragma xmp template t[N]
#pragma xmp nodes p[*]
#pragma xmp distribute t[block] onto p
#pragma xmp align a[i] with t[i]
#pragma xmp align b[i] with t[i]
...
#pragma acc enter data copyin(a, b)
#pragma xmp gmove acc
  a[:] = b[:];

#pragma xmp gmove acc(b)
  a[:] = b[:];
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XACC} {\bf gmove} construct}\label{code:gmove}
\end{myfigure}

In lines 2-6,
{\XMP} directives declare {\tt distributed arrays} {\it a} and {\it b}.
In line 8,
{\OACC} {\bf enter data} directive transfers the {\tt distributed arrays} {\it a} and {\it b} from host memory to accelerator memory.
In lines 9-10,
{\XACC} {\bf gmove} construct copies the whole {\tt distributed array} {\it b} to
that of the {\tt distributed array} {\it a} on accelerator memories.
In lines 12-13,
{\XACC} {\bf gmove} construct copies the whole {\tt distributed array} {\it b} on accelerator memory to
that of the {\tt distributed array} {\it a} on host memory.

\subsubsection{barrier Construct}\label{sec:barrier}
\subsubsection*{Synopsis}
The {\bf barrier} construct specifies an explicit barrier
at the point at which the construct appears.

\subsubsection*{Syntax}
\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt barrier} {\openb}{\tt on} {\it nodes-ref}
 $\vert${\it template-ref}{\closeb} {\openb}{\tt acc}{\closeb}\\
\verb![C]! & \verb|#pragma xmp| {\tt barrier} {\openb}{\tt on} {\it
     nodes-ref} $\vert$ {\it template-ref}{\closeb} {\openb}{\tt acc}{\closeb}\\
\end{tabular}

\subsubsection*{Description}
\begin{itemize}
 \item When the {\bf acc} clause is specified,
the barrier construct blocks until all outgoing asynchronous operations on accelerators are completed.
 \item When the {\bf acc} clause is not specified,
the barrier construct does not guarantee that an outgoing asynchronous operation on accelerator is completed.
\end{itemize}

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
!$xmp nodes p(*)
...
!$xmp barrier acc
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
#pragma xmp nodes p[*]
...
#pragma xmp barrier acc
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XACC} {\bf barrier} construct}\label{code:barrier}
\end{myfigure}

In line 1,
{\XMP} {\bf nodes} directive defines {\tt node set} {\it p}.
In line 3,
{\XACC} {\bf barrier} directive performs a barrier operation for accelerators on all {\tt node}.

\subsubsection{reduction Construct}\label{sec:reduction}
\subsubsection*{Synopsis}
The {\bf reduction} construct performs a reduction operation among {\tt nodes}.

\subsubsection*{Syntax}
\Syntax{reduction}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt reduction (} {\it reduction-kind} {\it
  :} {\it variable} {\openb}, {\it variable} {\closeb}... {\tt )}
 {\bsquare} \\
 & \hspace{5cm} {\bsquare} {\openb}{\tt on} {\it node-ref} $\vert$ {\it
     template-ref}{\closeb} {\openb}{\tt async (} {\it async-id} {\tt )}{\closeb} {\openb}{\tt acc}{\closeb}\\
\end{tabular}

\vspace{0.5cm}
where {\it reduction-kind} is one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\tt +} \\
 & {\tt *} \\
% & {\tt -} \\
 & {\tt .and.} \\
 & {\tt .or.} \\
 & {\tt .eqv.} \\
 & {\tt .neqv.} \\
 & {\tt max} \\
 & {\tt min} \\
 & {\tt iand} \\
 & {\tt ior} \\
 & {\tt ieor} \\
\end{tabular}

\vspace{0.5cm}

\begin{tabular}{ll}
 \hspace{-\parindent}
 \verb![C]! & \verb|#pragma xmp| {\tt reduction (} {\it reduction-kind} {\it
  :} {\it variable} {\openb}, {\it variable} {\closeb}... {\tt )}
 {\bsquare} \\
 & \hspace{5cm} {\bsquare} {\openb}{\tt on} {\it node-ref} $\vert$ {\it
     template-ref}{\closeb} {\openb}{\tt async (} {\it async-id} {\tt )}{\closeb} {\openb}{\tt acc}{\closeb} \\
\end{tabular}
\vspace{0.5cm}

where {\it reduction-kind} is one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\tt +} \\
 & {\tt *} \\
% & {\tt -} \\
 & {\verb|&|} \\
 & {\tt |} \\
 & {\verb|^|} \\
 & {\verb|&&|} \\
 & {\tt ||} \\
 & {\tt max} \\
 & {\tt min} \\
\end{tabular}

\subsubsection*{Description}
When the {\bf acc} clause is specified,
the {\tt reduction} construct performs a type of
reduction operation specified by {\it reduction-kind} for the specified
local variables among the accelerators and 
sets the reduction results to the variables on each of the accelerators.

\subsubsection*{Restriction}
\begin{itemize}
 \item When the {\bf acc} clause is specified,
   the variables specified by the sequence of {\it variable}'s must be allocated on accelerator memory.
 \item This construct must not appear in {\OACC} {\tt parallel region}.
\end{itemize}

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
integer :: a
!$xmp nodes p(*)
...
!$acc enter data copyin(a)
!$xmp reduction(+:a) acc
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
int a;
#pragma xmp nodes p[*]
...
#pragma acc enter data copyin(a)
#pragma xmp reduction(+:a) acc
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XACC} {\bf reduction} construct}\label{code:reduction}
\end{myfigure}

In line 2,
{\XMP} {\bf nodes} directive defines {\tt node set} {\it p}.
In line 4,
{\OACC} {\bf enter data} directive transfers the local variable {\it a} from host memory to accelerator memory.
In line 5,
{\XACC} {\bf reduction} directive calculates a total value of the variable {\it a} stored on each accelerator
memory in each {\tt node}.

\subsubsection{bcast Construct}\label{sec:bcast}
\subsubsection*{Synopsis}
The {\bf bcast} construct performs broadcast communication from a specified {\tt node}.

\subsubsection*{Syntax}

\begin{tabular}{ll}
 \verb![F]! & \verb|!$xmp| {\tt bcast} \verb|(| {\it variable}
 {\openb}, {\it variable}{\closeb}... \verb|)|
 {\openb}{\tt from} {\it nodes-ref} $\vert$ {\it template-ref}{\closeb}
 {\bsquare} \\
 & \hspace{4.8cm} {\bsquare} {\openb}{\tt on} {\it nodes-ref}{\closeb}
     $\vert$ {\it template-ref}{\closeb}
     {\openb}{\tt async (} {\it async-id} {\tt )}{\closeb} {\openb}{\tt acc}{\closeb}\\

 \verb![C]! & \verb|#pragma xmp| {\tt bcast} \verb|(| {\it variable}
 {\openb}, {\it variable}{\closeb}... \verb|)|
 {\openb}{\tt from} {\it nodes-ref}  $\vert$ {\it
     template-ref}{\closeb} {\bsquare} \\
 & \hspace{4.8cm} {\bsquare} {\openb}{\tt on} {\it nodes-ref} $\vert$ {\it
     template-ref}{\closeb}
 {\openb}{\tt async (} {\it async-id} {\tt )}{\closeb} {\openb}{\tt acc}{\closeb}\\
\end{tabular}

\subsubsection*{Description}
When the {\bf acc} clause is specified, 
the values of the variables specified by the sequence of {\it variable}'s on accelerator memory
(called {\tt broadcast variables}) are broadcasted
from the {\tt node} specified by the {\tt from} clause (called the
{\tt source node}) to each of the {\tt nodes} in the {\tt node set} specified
by the {\tt on} clause. After executing this construct,
the values of the {\tt broadcast variables} become the same as those in the {\tt source node}.

\subsubsection*{Restriction}
\begin{itemize}
 \item When the {\bf acc} clause is specified,
   the variables specified by the sequence of {\it variable}'s must be allocated on accelerator memory.
 \item This construct must not appear in {\OACC} {\tt parallel region}.
\end{itemize}

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
integer :: a
!$xmp nodes p(*)
...
!$acc enter data copyin(a)
!$xmp bcast(a) acc
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
int a;
#pragma xmp nodes p[*]
...
#pragma acc enter data copyin(a)
#pragma xmp bcast(a) acc
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XACC} {\bf bcast} construct}\label{code:bcast}
\end{myfigure}

In line 2,
{\XMP} {\bf nodes} directive defines {\tt node set} {\it p}.
In line 4,
{\OACC} {\bf enter data} directive transfers the local variable {\it a} from host memory to accelerator memory.
In line 5,
{\XACC} {\bf bcast} directive broadcasts the variable {\it a} stored on accelerator memory to all {\it nodes}.

\subsubsection{wait\_async Construct}\label{sec:waitasync}
\subsubsection*{Synopsis}
The {\bf wait\_async} construct guarantees asynchronous
communications specified by {\it async-id} are complete.

\subsubsection*{Syntax}
\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt wait\_async ( {\it async-id} {\openb},
 {\it async-id} {\closeb}...)} {\openb}{\tt on} {\it nodes-ref} $\vert$
 {\it template-ref}{\closeb} {\openb}{\tt acc}{\closeb}\\
\verb![C]! & \verb|#pragma xmp| {\tt wait\_async ( {\it async-id} {\openb},
 {\it async-id} {\closeb}...)} {\openb}{\tt on} {\it nodes-ref} $\vert$
 {\it template-ref}{\closeb} {\bsquare} \\
& \hspace{13.5cm} {\bsquare} {\openb}{\tt acc}{\closeb}\\
\end{tabular}

\subsubsection*{Description}
When the {\bf acc} clause is specified,
the {\bf wait\_async} construct blocks and therefore
statements following it are not executed until all of the asynchronous
communications that are specified by {\it async-id}'s and issued on the accelerators in
{\tt node set} specified by the {\tt on} clause are complete.

\subsubsection*{Restriction}
This construct must not appear in {\OACC} {\tt parallel region}.

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
integer :: a
!$xmp nodes p(*)
...
!$acc enter data copyin(a)
!$xmp reduction(+:a) acc async(1)
...
!$xmp wait_async(1) acc
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
int a;
#pragma xmp nodes p[*]
...
#pragma acc enter data copyin(a)
#pragma xmp reduction(+:a) acc async(1)
...
#pragma xmp wait_async(1) acc
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XACC} {\bf wait\_async} construct}\label{code:waitasync}
\end{myfigure}

In line 2,
{\XMP} {\bf nodes} directive defines {\tt node set} {\it p}.
In line 4,
{\OACC} {\bf enter data} directive transfers the local variable {\it a} from host memory to accelerator memory.
In line 5,
{\XACC} {\bf reduction} directive performs asynchronously.
In line 7,
{\XACC} {\bf wait\_async} construct blocks until the asynchronous {\bf reduction} operation at line 5 is complete.

\subsection{Coarray Features} \label{sec:coarray}
\subsubsection*{Synopsis}
{\XACC} can perform one-sided communication (put/get operations) for data on accelerator memory using {\tt coarray} features,
which is based on {\XMP} local-view memory model.
A combination of {\tt coarray} syntax and {\OACC} {\bf host\_data} construct enables communication between accelerators.

\subsubsection*{Description}
If {\tt coarrays} appear in {\OACC} {\bf use\_device} clause of any {\OACC} enclosing {\bf host\_data} construct, 
communication targets data on the accelerator side. 
{\tt Coarray} operations on accelerators are synchronized using the same synchronization functions in {\XMP}.

\subsubsection*{Restriction}
\begin{itemize}
 \item Only {\OACC} {\bf declare} directive can declare a {\tt coarray} on accelerator memory.
   For example,
   {\OACC} {\bf enter data} and {\bf copy} directives cannot declare a {\tt coarray} on accelerator memory.
 \item The {\tt coarray} syntax must not appear in {\OACC} {\tt parallel region}.
\end{itemize}

\subsubsection*{Example}
\begin{myfigure}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XACCFexampleL}
integer :: a(N)[*]
integer :: b(N)
!$acc declare create(a, b)
...
if(this_image() == 1) then
!$acc host_data use_device(a, b)
  a(:)[2] = b(:)

!$acc host_data use_device(a)
  b(:) = a(:)[3]
end if
...
sync all
\end{XACCFexampleL}
\end{center}
\end{minipage}
%
\begin{minipage}{0.53\hsize}
\begin{center}
\begin{XACCCexampleR}
int a[N]:[*];
int b[N];
#pragma acc declare create(a, b)
...
if(xmp_node_num() == 1){
#pragma acc host_data use_device(a, b)
  a[:]:[2] = b[:];

#pragma acc host_data use_device(a)
  b[:] = a[:]:[3];
}
...
xmp_sync_all(NULL);
\end{XACCCexampleR}
\end{center}
\end{minipage}
\caption{Code example in {\XACC} coarray features}\label{code:coarray}
\end{myfigure}

In line 3,
{\OACC} {\bf declare} directive declares a {\tt coarray} {\it a} and a array {\it b} on accelerator memory.
In lines 6-7,
{\tt node} 1 performs put operation, where
the whole array {\it b} on accelerator memory in {\tt node} 1 is transferred to the {\tt coarray} {\it a} on accelerator memory in {\tt node} 2.
In lines 9-10,
{\tt node} 1 performs get operation, where
the whole {\tt coarray} {\it a} on accelerator memory in {\tt node} 3 is transferred to the array {\it b} on host memory in {\tt node} 1.
In line 13,
the {\bf sync all} statement in {\XACCF} or the {\bf xmp\_sync\_all} function in {\XACCC} synchronizes all {\tt nodes} and guarantees completion of ongoing coarray operations.

